# -*- coding:utf-8-*-
"""
    project: network models
    author: cherish_zhang(2015.5/22)
    method: preferential attachment model
            (higher degree nodes get more attention from newly added nodes)
            ps: the degree for directed graph is out + in
"""
import numpy as np
from scipy.stats import poisson
import random
import csv


def add_to_dict(dict, key, value):
    if key not in dict:
        dict.setdefault(key, int(value))
    else:
        dict[key] += int(value)
#----------------------------------------------------------#


""" Load graph data from a file stored at specific path
    The file's format is follow:
        1,2\n
        1,4\n
        ......
    para:
        path: where the file is stored
    return: a graph represented by list
"""
def load_graph_data(path):
    graph = []
    file = csv.reader(open(path))
    for line in file:
        graph.append([int(line[0]), int(line[1])])
    return graph
#------------------------------------------------------#


""" Generate a random undirected graph
    para:
        m0: the number of nodes with degrees at least 1
    return: a scale-free network generated random
"""
def random_graph_gen(m0):
    graph = []
    node_degrees = {}
    while len(node_degrees) != m0:
        node_a = random.randint(1, m0)
        node_b = random.randint(1, m0)
        while [node_a, node_b] in graph or [node_b, node_a] in graph or node_a == node_b:
            node_b = random.randint(1, m0)
        graph.append([node_a, node_b])
        add_to_dict(node_degrees, node_a, 1)
        add_to_dict(node_degrees, node_b, 1)
    return graph
#----------------------------------------------------------#


""" preferential attachment model
    para:
        init_graph: dict for graph
                    eg.{"nodes":[0,1,2,3,4],"edges":[[1,2],[1,3],[2,3]]} 
        expected_connections: the expected edges for new added nodes
        t: the number of new added nodes
    return: a scale-free network generated by PAM
"""
def preferential_attachment_gen(init_graph, expected_connections, t):
    if init_graph == {}:
        print "error: the original graph is null!"
        return
    edges = init_graph["edges"]
    nodes = init_graph["nodes"]
    if nodes == [] or edges == []:
        print "error: the original graph is null!"
        return
    #----map nodes to integers
    nodes_dict = { name : i for i, name in list(enumerate(nodes)) }
    #---compute nodes's degree in the inital graph
    node_degrees = {}
    for n in nodes:
        node = nodes_dict[n]
        add_to_dict(node_degrees, node, 0)
    for [na, nb] in edges:
        node_a = nodes_dict[na]
        node_b = nodes_dict[nb]
        add_to_dict(node_degrees, node_a, 1)
        add_to_dict(node_degrees, node_b, 1)
    #----compute the m0(nodes with at least one degree)
    m0 = 0
    max_node_num = nodes_dict[nodes[0]]
    for n in nodes:
        node = nodes_dict[n]
        if max_node_num < node:
            max_node_num = node
        if node_degrees[node] >= 1:
            m0 += 1
    if m0 < expected_connections:
        print "error: the expected connections for a new added node is too large!"
        return
    #-----------------------------------------------------------#
    #----the first ingredient:the growth element----#
    for i in xrange(1, t+1):
        node_vi = max_node_num + 1 #---add a new node vi---#
        degree_of_vi = 0
        #---the second ingredient:the preferential attachment element---#
        while degree_of_vi != expected_connections:
            #enumerate all nodes in the graph according to degrees
            clist = []
            for j in nodes:
                node_j = nodes_dict[j]
                if node_degrees[node_j] > 0:
                    for _ in xrange(node_degrees[node_j]):
                        clist.append(j)
            #---connect vi to a random node vj with probability---#
            node_vj = random.choice(clist)
            while [node_vi, node_vj] in edges or [node_vj, node_vi] in edges:
               node_vj = random.choice(clist)
            edges.append([node_vi, node_vj])
            degree_of_vi += 1
        #---insert the new node to the given graph----#
        nodes.append(node_vi)
        max_node_num += 1
        nodes_dict.setdefault(node_vi, node_vi)
        add_to_dict(node_degrees, node_vi, degree_of_vi)

    graph = {}
    graph["nodes"] = nodes
    graph["edges"] = edges
    return graph
#-------------------------------------------------------------------#


""" Poisson Growth model
    para:
        init_graph: a small seed network of t0 nodes
        a: the offset of the nodes' degrees
        b: the constant degrees of the acnodes
        expected_connections: the expected edges for new added nodes
                            the actual edges follow the poisson distribution.
        t: the number of new added nodes
    return: a scale-free network generated by PG
    
    we define function r(k):
        r(k) = k + a, k>=1 and r(0) = b
"""
def poisson_growth_gen(init_graph, a, b, expected_connections, t):
    if init_graph == {}:
        print "error: the original graph is null!"
        return
    edges = init_graph["edges"]
    nodes = init_graph["nodes"]
    if nodes == [] :
        print "error: the original graph is null!"
        return
    #----map nodes to integers
    nodes_dict = { name : i for i, name in list(enumerate(nodes)) }
    #---compute nodes's degree in the inital graph
    node_degrees = {}
    for n in nodes:
        node = nodes_dict[n]
        add_to_dict(node_degrees, node, 0)
    for [na, nb] in edges:
        node_a = nodes_dict[na]
        node_b = nodes_dict[nb]
        add_to_dict(node_degrees, node_a, 1)
        add_to_dict(node_degrees, node_b, 1)
    #----compute the m0(nodes with at least one degree)
    m0 = 0
    max_node_num = nodes_dict[nodes[0]]
    for n in nodes:
        node = nodes_dict[n]
        if max_node_num < node:
            max_node_num = node
        if node_degrees[node] >= 1:
            m0 += 1
    if m0 < expected_connections:
        print "error: the expected connections for a new added node is too large!"
        return
    #-----------------------------------------------------------#
    #----the first ingredient:the growth element----#
    for i in xrange(1, t+1):
        node_vi = max_node_num + 1 #---add a new node vi---#
        degree_of_vi = 0
        #---the second ingredient:the poisson distribution element---#
        poisson_variates = poisson.rvs(expected_connections, size = 1000) # generate random numbers
        actual_connections = random.choice(poisson_variates)
        #print "actual: ", actual_connections
        while degree_of_vi != actual_connections:
            #---compute the function r(k)---#
            clist = []
            for j in nodes:
                node_j = nodes_dict[j]
                if node_degrees[node_j] > 0:
                    for _ in xrange(node_degrees[node_j] + a):
                        clist.append(j)
                else:
                    for _ in xrange(b):
                        clist.append(j)
            #print clist
            #---connect vi to a random node vj with probability---#
            node_vj = random.choice(clist)
            while [node_vi, node_vj] in edges or [node_vj, node_vi] in edges:
                node_vj = random.choice(clist)
            edges.append([node_vi, node_vj])
            degree_of_vi += 1
        #---insert the new node
        nodes.append(node_vi)
        max_node_num += 1
        nodes_dict.setdefault(node_vi, node_vi)
        add_to_dict(node_degrees, node_vi, degree_of_vi)

    graph = {}
    graph["nodes"] = nodes
    graph["edges"] = edges
    return graph
#-------------------------------------------------------------------#
    
    

if __name__ == '__main__':
    graph = {"nodes":[0,"a","b",3,4,5,6],"edges":[["a","b"],["a",4],["a",5],["a",6]]}
    graph = preferential_attachment_gen(graph, 3, 4)
    graph = poisson_growth_gen(graph, 2, 3, 3, 4)
    print "final graph:\n", graph
